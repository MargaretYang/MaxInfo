
#ifndef BATCH_MODE_H
#define BATCH_MODE_H

#include "Read_Assignment.h"
#include "Entropy.h"

/////////////////////////////////////////////////////////
//// reads generated by gene
//// annotations are assumed to exist
class Gene_Batch
{
public:
	int gene_Number;          // number of genes
	int rd_Len;               // length of read
	float fragLen_Mean;       // average of length of read
	float fragLen_Var;        // variance of length of read
	int read_Number;          // number of segments
	string chromosome_Name;   // chromosome name
	string next_chromoName;   // next chromosome name
	string pre_orientation;   // last area orientation
	int chromosome_Num;       // number of chromosome
	ofstream record_file;     // input file
	ofstream read_file;       // read on each chromosome
	string pre_line;          // current line
	int starting_site;        // start point of transcript
	int starting_site_1;      // start point of transcript
	int ending_site;          // end point of transcript
	int ending_site1;         // end point of transcript in the positive direction
	int ending_site2;         // end point of transcript in the negtive direction   
	int site_1;               // start point 1 of transcript
	int site_2;               // end point 1 of transcript
	vector<int> starting_site_vec;  // start point of transcript
	vector<int> ending_site_vec;    // end point of transcript
	vector<PAIR_INT> non_Link;      // exons which are not connected
	int method_Mode;		        // mode

	VEC_NODE exon_Assembly;     // exon
	vector<float> exon_Score;   // score of exon
	vector<int> exon_Type;      // type of exon
	vector<VEC_NODE> rev_ExonAssembly;        // exon in the negtive direction
	vector<vector<VEC_INT>> rev_intraPairs;   // insert point in the negtive direction	
	vector<vector<float>> rev_ExonScore;      // score of exon in the negtive direction
	vector<vector<int>> rev_ExonType;         // type of exon in the negtive direction
	VEC_NODE rev_exonAssembly;     // exon in the negtive direction
	vector<float> rev_exonScore;   // score of exon in the negtive direction
	vector<int> rev_exonType;      // type of exon in the negtive direction
	vector<PAIR_INT> junction;     // hop point
	vector<int> start_sites;
	vector<int> stop_sites;
	vector<PAIR_INT> transcription_sites;	// start point and end point of transcript from annotation
	Gene cur_Gene;							// gene identified by the isoform

	vector<vector<int>> rd_Left;  // number of read within each interval
	vector<vector<int>> rd_Right; // number of read within each interval
	vector<Rd> rd_Bak;            // read in the temporary interval

	vector<Rd_Set> rd_setBatch;
	vector<Graph_Trans> graph_setBatch;
	vector<vector<Exon_Node>> intron_Add;   // intron
	vector<vector<int>> serial_Add;         // intron index

	vector<Gene> gene_Locus;                // candidate gene assembled to the location
	vector<vector<PAIR_INT>> junc_Pair;     // hop point
	vector<int> junc_Num;                   // number of hop point
	vector<vector<int>> stack_exonBoundary; // exon boundary
	vector<int> rev_breakPoints;
	vector<PAIR_INT> sus_Junc;              // hop point with low confidence
	bool intra_activeFlag;

public:
	void report();  
	void abun_Estimation(char* filename1, char* filename2, string chromo_Name);			// abundance esitmation of transcript
	void ini_Graph(Graph_Trans& gph, string Gene_Id, int serial, ifstream& infile);		// graph initialization
	void exon_Pose(vector<int>& exon_Start, vector<int>& exon_Stop);					// analysis the exon
	void exon_Insertion(vector<Exon_Node>& exon_Node, int start, int stop);				// insert new exon
	void locate_transcriptionSites(Gene& gene, vector<PAIR_INT>& sites);				// locate possible start site and end site of transcription

	void load_Annotation(vector<Gene>& gene, char* filename1, string chromo_Name);		// load annotation
	int  load_Annotation_1(vector<Gene>& gene, char* filename1, string chromo_Name);	// load annotation
	int  rdLen_estimation(char* filename1);												// obtain length of read
	void fgLen_estimation(char* filename1,char* filename2);								// estimation of distribution of fragment length
	void estimation_Compare(int candidate, string gene_Name, vector<Trans>& trs_SetCtrl, vector<Trans>& trs_SetCase, float& precision, float& recall);   // compare the result
	void output_Comparison(int candidate, string gene_Name, vector<Trans>& trs_SetCtrl, vector<Trans>& trs_SetCase, float precision, float recall, ofstream& outfile);   // output the result
	
	void output_GeneAnnotation(char* filename, vector<Gene>& gene);        // write the gene annotation to file
	void output_transBed(char* path1, char* filename, vector<Gene>& gene); // write the gene information to file
	void output_standardBed(char* path1, char* filename, vector<Gene>& gene, string chromo_Name); // write the gene information to file
	void refGene_transBed(char* filename1, char* filename2);  // transfer the refGene format files to bed format
	void refGene_transBed(char* filename1, char* filename2, char* chromo_Name); // transfer the refGene format files to bed format
	void separate_File(char* filename1, char* filename2);     // devide the files by chromosome
	void statistical(char* filename1, char* filename2);       // calculate the distribution of the number of exons and isoforms
	void select_Trans(char* filename1, char* filename2, vector<string>& chr_Name, int trs1, int trs2, int exon1, int exon2);   // sselect some isoform
	void gtf2bed(char* filename1, char* filename2);
	
	void trans_Compare(char* filename1, char* filename2, char* filename3);  // exon comparison
	void exon_Assemble(char* filename1, char* filename);   // exon assembly
	void exon_Print(char* filename);   // output the result of exon assembly
	void exon_PrintBatch(ofstream& outfile, int gene_Cnt, vector<Exon_Node>& exon_Vec);
	void abun_EstimationSpr(char* filename1, char* filename2, char* data_path, string chromo_Name);  // abundance estimation of transcription
	void ini_GraphSpr(vector<Gene>& Gene_Set, char* filename1, string chromo_Name);  // write gene structure according to the annotation
	void bounding_Assemble(ifstream& infile, vector<int>& exon_Start, vector<int>& exon_Stop);  // start point and end point of transcript assembly
	void coverage_Assemble(ifstream& infile, Rd_Set& rd_Set);  // start point and end point of transcript assembly
	bool check_Intron(int x1, int x2, int& z1, int& z2, vector<int>& right_Boundary);   // check whether the exon should be deleted

	// transcript assembly according to junction
	bool exon_AssembleBatch(ifstream& infile, ifstream& infile2, vector<int>& exon_Start, 
		vector<int>& exon_Stop);

	// find break point
	bool locate_Jump(vector<int>& points, int rd_Num, int idx, int bound1, int bound2, float jump_Thresh, float boundary_Thresh,
		vector<int>& pair_Jump, vector<int>& cnt, vector<int>& gap);

	// write the graph of each gene to file
	void gene_LocateOutput(Rd_Set& rd_Set, Graph_Trans& gph, string gene_Name, ofstream& outfile, int serial);

	// isoform identification and abundance estimation on each gene
	bool abun_EstiSingle(Rd_Set& rd_Set, Graph_Trans& gph, char* data_path,int mode = 0);

	////////////////////////////////////////////////////////////////////////////////////////
	// deal with data with intron-retention 
	// deal with the assignment of sequencing data
	int  assignment_Pose(Rd_Set& rd_Set, Graph_Trans& gph, ifstream& infile, string chromo_Name);
	bool assignment_Pose_1(Gene& gene, Rd_Set& rd_Set, Graph_Trans& gph, ifstream& infile, string chromo_Name);
	
	// transcript assembly and abundance estimation according to the sequencing data
	void batch_AbunEstimation(char* filename1, char* filename2, char* data_path);

	// transcript assembly and abundance estimation according to the sequencing data
	void abun_EstimationSpr_1(char* filename1, char* filename2, char* data_path);

	// transcript assembly and abundance estimation according to the sequencing data
	void abun_EstimationSpr_2(char* filename1, char* filename2, char* filename3, char* data_path);

	// abundance estimation
	void abun_Estimation(char* filename1, char* filename2, char* data_path, string chromo_Name);

	// transcript assembly according to annotation
	bool assembly_Annotation(ifstream& infile, vector<Gene>& gene);

	// correct transcript assembly according to annotation
	void exon_CompareAnno(vector<Exon_Node>& exon_Vec, vector<Exon_Node>& exon_Vec_Anno, Gene& cur_Gene, vector<vector<int>>& junc_Num);
	
	// insert between two genes
	int interval_Assembly(ifstream& infile, vector<PAIR_INT>& junction, vector<int>& orientation, vector<Gene>& gene_Set, int& serial);
	
	// junction located within the gene
	bool locate_Junction(ifstream& infile, Gene& cur_Gene, vector<int>& exon_start, vector<int>& exon_stop, vector<vector<int>>& junc_Num);
	
	// junction located within the gene
	void locate_Junction_Interval(ifstream& infile, vector<Gene>& gene_Set, int serial, vector<PAIR_INT> junction, vector<int>& orientation);
	
	// check the connection of exons and intron-retention on the gene
	int locus_Assemble(ifstream& infile, Rd_Set& rd_Set, Graph_Trans& gph, vector<Exon_Node>& exon_Assembly);

	// modify the graph accrding to the real data
	bool graph_Modify(Rd_Set& rd_Set, Graph_Trans& gph);

	// modify interval index of read accrding to the real data
	bool serial_Modify(Rd_Set& rd_Set, Graph_Trans& gph);

	// check intron-retention
	bool intron_Retention(Rd_Set& rd_Set, Graph_Trans& gph, vector<vector<int>>& intron_Junc1,
		vector<vector<int>>& intron_Junc2, vector<vector<int>>& rd_Left, vector<vector<int>>& rd_Right);

	// check the relation of the interval according to the ends of read and split point
	bool junc_Linkage(Graph_Trans& gph, vector<int>& points_1, vector<int>& readIdx);

	// check whether isoform within the interval can be identified and abundance can be estimated
	bool check_Valid(Rd_Set& rd_Set, Graph_Trans& gph);

	// locate read
	int read_Locate(vector<int>& seg_Left, vector<int>& seg_Right, vector<int>& right_Boundary,
		vector<int>& single_rBoundary, vector<int>& exon_Start, vector<int>& exon_Stop, ifstream& infile, Rd_Set& rd_Set);	

	// check transcript assembly
	bool assemble_SubGraph(vector<vector<int>>& seg_Modify);
	// calculate the cover rate of read in the intron
	int intron_Coverage(vector<int>& Rank);
	// locate new interval
	int interval_Locate(Interval& seg, vector<vector<int>>& seg_Modify);
	// locate new interval
	int interval_Locate_1(Interval& seg, vector<vector<int>>& seg_Modify);
	
	// calculate hop score
	int cal_Rate(vector<int>& site, vector<int>& cnt, vector<int>& gap, int num, vector<float>& rate, int& m_idx1, int& m_idx2);

	// calculate hop score
	float cal_Rate_1(int serial, vector<int>& site, vector<int>& cnt, vector<int>& gap, int num, vector<float>& rate, int& m_idx1, int& m_idx2);

	// modify the gene
	// return the number of gene
	int gene_Modify(vector<Gene>& gene_Set, vector<vector<int>>& seg_Modify);

	// check whether the two hop points match
	bool match_Identify(int idx_1, int idx_2, int change_type, vector<int>& temp1, vector<int>& temp2);

	// locate split point
	void points_Locate(int idx_1, int idx_2, int serial, int s1, vector<int>& temp1, vector<int>& temp2, vector<int>& points);

	// check whether the genes overlap
	int gene_Overlap(ifstream& infile, string orientation, int& pre_meStart, int& pre_meStop, int site1, int site2, 
		vector<vector<int>>& reverse_Pair, vector<int>& exon_Start, vector<int>& exon_Stop);

	// check whether the inner genes overlap
	int intra_Overlap(ifstream& infile, string orientation, int& pre_meStart, int& pre_meStop, int site1, int site2,
		vector<vector<int>>& reverse_Pair, vector<int>& exon_Start, vector<int>& exon_Stop);

	// exon assembly
	bool exon_Predict(vector<int>& exon_Start, vector<int>& exon_Stop, int start_site, int end_site, 
		vector<Exon_Node>& exon_Vec, vector<int>& exon_type, vector<float>& exon_score);

	// format conversion 
	int expression_conver(char* filename1, char* filename2, int total_Number);

};

#endif